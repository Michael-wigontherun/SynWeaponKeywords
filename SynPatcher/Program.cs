using System;
using System.Net.Http;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.FormKeys.SkyrimSE;

using Noggog;

using WeaponKeywords.Types;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json;

using Microsoft.AspNetCore.JsonPatch;
using Microsoft.AspNetCore.JsonPatch.Operations;
using Microsoft.AspNetCore.JsonPatch.Exceptions;
using System.Drawing;

namespace WeaponKeywords;
public class Program
{
    static Lazy<Database> LazyDB = new();
    static Database DB => LazyDB.Value;
    static List<FormKey> OneHandedType = new() { Skyrim.EquipType.EitherHand.FormKey, Skyrim.EquipType.LeftHand.FormKey, Skyrim.EquipType.RightHand.FormKey };
    static List<FormKey> TwoHandedType = new() { Skyrim.EquipType.BothHands.FormKey };
    static List<WeaponAnimationType> OneHandedAnims = new() { WeaponAnimationType.OneHandAxe, WeaponAnimationType.OneHandSword, WeaponAnimationType.OneHandDagger, WeaponAnimationType.OneHandMace, WeaponAnimationType.Staff };
    static List<WeaponAnimationType> TwoHandedAnims = new() { WeaponAnimationType.Bow, WeaponAnimationType.Crossbow, WeaponAnimationType.TwoHandSword, WeaponAnimationType.TwoHandAxe };
    static Dictionary<EQEnum, IFormLink<IEquipTypeGetter>> EQT = new() {
        {EQEnum.BothHands, Skyrim.EquipType.BothHands},
        {EQEnum.EitherHand, Skyrim.EquipType.EitherHand},
        {EQEnum.LeftHand, Skyrim.EquipType.LeftHand},
        {EQEnum.RightHand, Skyrim.EquipType.RightHand}
    };
    public static async Task<int> Main(string[] args)
    {
        return await SynthesisPipeline.Instance
            .SetAutogeneratedSettings("Database", "database.json", out LazyDB)
            .AddRunnabilityCheck(ConvertJson)
            .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
            .SetTypicalOpen(GameRelease.SkyrimSE, "SynWeaponKeywords.esp")
            .Run(args);
    }
    public static async void ConvertJson(IRunnabilityState state)
    {
        JObject? DBConv = null;
        if (!Directory.Exists(state.ExtraSettingsDataPath))
        {
            Directory.CreateDirectory(state.ExtraSettingsDataPath!);
        }
        if (File.Exists(Path.Combine(state.ExtraSettingsDataPath!, "database.json")))
        {
            DBConv = JObject.Parse(File.ReadAllText(Path.Combine(state.ExtraSettingsDataPath!, "database.json")));
        }
        if (DBConv == null || (DBConv["DBVer"]?.Value<int>() ?? 0) <= 0)
        {
            DBConv = new JObject();
            DBConv["DBVer"] = 0;
        }
        //JSON Patch based DB-Updates
        using (var HttpClient = new HttpClient())
        {
            HttpClient.Timeout = TimeSpan.FromSeconds(5);
            string resp = string.Empty;
            try
            {
                resp = await HttpClient.GetStringAsync("https://raw.githubusercontent.com/minis-patchers/SynDelta/main/SynWeaponKeywords/index.json");
            }
            catch (Exception)
            {
                Console.WriteLine("Failed to download patch index");
                return;
            }
            var pi = JArray.Parse(resp).ToObject<List<string>>()!;
            for (int i = DBConv["DBVer"]!.Value<int>(); i < pi.Count; i++)
            {
                try
                {
                    Console.WriteLine($"Downloading patch {pi[i]}");
                    resp = await HttpClient.GetStringAsync(pi[i]);
                }
                catch (Exception)
                {
                    Console.WriteLine($"Failed to download patch {pi[i]}");
                    return;
                }
                var pch = new JsonPatchDocument(JsonConvert.DeserializeObject<List<Operation>>(resp), new DefaultContractResolver());
                try
                {
                    pch.ApplyTo(DBConv);
                }
                catch (JsonPatchException ex)
                {
                    Console.WriteLine($"Failed to apply patch {pi[i]} {ex.Message}");
                    Console.WriteLine($"Failed Object {ex.AffectedObject}");
                    Console.WriteLine($"Operation {ex.FailedOperation}");
                    Console.WriteLine("Database patching terminated");
                    return;
                }
                File.WriteAllText(Path.Combine(state.ExtraSettingsDataPath!, "database.json"), JsonConvert.SerializeObject(DBConv, Formatting.Indented));
            }
        }
    }
    public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
    {
        Console.WriteLine($"Running with Database Patch: V{DB.DBVer}");
        Dictionary<string, List<IKeywordGetter>> formkeys = new();
        var Keywords = DB.DB.SelectMany(x => x.Value.keyword).Distinct();
        foreach (var kyd in DB.DB.Select(x => x.Key))
        {
            formkeys[kyd] = new List<IKeywordGetter>();
        }
        foreach (var src in DB.sources)
        {
            if (!state.LoadOrder.PriorityOrder.Select(x => x.ModKey).Contains(src)) continue;
            state.LoadOrder.TryGetValue(src, out var mod);
            if (mod != null && mod.Mod != null && mod.Mod.Keywords != null)
            {
                var keywords = mod.Mod.Keywords
                    .Where(x => Keywords.Contains(x.EditorID ?? ""))
                    .ToList() ?? new List<IKeywordGetter>();
                foreach (var keyword in keywords)
                {
                    if (keyword == null) continue;
                    var type = DB.DB.Where(x => x.Value.keyword.Contains(keyword.EditorID ?? "")).Select(x => x.Key);
                    Console.WriteLine($"Keyword : {keyword.FormKey.ModKey} : {keyword.EditorID}");
                    foreach (var tp in type)
                    {
                        formkeys[tp].Add(keyword);
                    }
                }
            }
        }
        if (DB.Gen)
        {
            foreach (var kywd in DB.InjectedKeywords)
            {
                var type = DB.DB.Where(x => x.Value.keyword.Contains(kywd.Key ?? "")).Select(x => x.Key).ToHashSet();
                var key = new Keyword(kywd.Value, SkyrimRelease.SkyrimSE);
                key.EditorID = kywd.Key;
                key.Color = Color.Black;
                state.PatchMod.Keywords.Add(key);
                Console.WriteLine($"Added Keyword : {key.FormKey.IDString()}:{key.FormKey.ModKey} : {key.EditorID}");
                foreach (var tp in type)
                {
                    formkeys[tp].Add(key);
                }
            }
        }
        foreach (var weapon in state.LoadOrder.PriorityOrder.Weapon().WinningOverrides())
        {
            if (!weapon.Template.IsNull) continue;
            var edid = weapon.EditorID;
            var matchingKeywords = DB.DB
                .Where(kv => kv.Value.commonNames.Any(cn => weapon.Name?.String?.Contains(cn, StringComparison.OrdinalIgnoreCase) ?? false))
                .Where(kv => !kv.Value.excludeNames.Any(en => weapon.Name?.String?.Contains(en, StringComparison.OrdinalIgnoreCase) ?? false))
                .Where(kv => !kv.Value.exclude.Contains(weapon.FormKey))
                .Where(kv => !DB.excludes.excludeMod.Contains(weapon.FormKey.ModKey))
                .Where(kv => !DB.excludes.phrases.Any(ph => (weapon.Name?.String?.Contains(ph, StringComparison.OrdinalIgnoreCase) ?? false)))
                .Where(kv => !DB.excludes.weapons.Contains(weapon.FormKey))
                .Select(kv => kv.Key)
                .Concat(DB.DB.Where(x => x.Value.include.Contains(weapon.FormKey)).Select(x => x.Key))
                .Distinct()
                .ToArray();
            var isOneHanded = OneHandedType.Any(x => x.Equals(weapon.EquipmentType.FormKey));
            IWeapon? nw = null;
            if (matchingKeywords.Length > 0)
            {
                Console.WriteLine($"{edid} - {weapon.FormKey.IDString()}:{weapon.FormKey.ModKey} matches: {string.Join(",", matchingKeywords)}");
                Console.WriteLine($"\t{weapon.Name}: {weapon.EditorID} is {string.Join(" & ", DB.DB.Where(x => matchingKeywords.Contains(x.Key)).Select(x => x.Value.outputDescription))}");
                var keywords = weapon.Keywords?
                    .Select(x => x.TryResolve<IKeywordGetter>(state.LinkCache, out var kyd) ? kyd : null)
                    .Where(x => x != null)
                    .Where(x => !x!.EditorID.StartsWith("WeapType"))
                    .Concat(
                        matchingKeywords.SelectMany(
                            x => formkeys[x].Where(y => !DB.DB[x].excludeSource.Contains(y.FormKey.ModKey))
                        )
                    )
                    .Select(x => x!)
                    .DistinctBy(x => x.FormKey)
                    .ToList() ?? new();

                if (keywords.Any(x => !(weapon.Keywords?.Contains(x) ?? false)))
                {
                    nw = nw == null ? state.PatchMod.Weapons.GetOrAddAsOverride(weapon)! : nw!;
                    nw.Keywords = keywords.Select(x => x.ToLinkGetter()).ToExtendedList();
                    Console.WriteLine($"\tSetting keywords to:\n\t\t{string.Join("\n\t\t", keywords.Select(x => $"{x.EditorID} from {x.FormKey.ModKey}"))}");
                }
                var fKeyword = matchingKeywords.First();
                IFormLink<IEquipTypeGetter> equipType = EQT[DB.DB[fKeyword].EQType];
                if (DB.DB[fKeyword].NameOverrides.Any(x => weapon?.Name?.String?.Contains(x.Contains, StringComparison.OrdinalIgnoreCase) ?? false))
                {
                    equipType = EQT[DB.DB[fKeyword].NameOverrides.Where(x => weapon?.Name?.String?.Contains(x.Contains, StringComparison.OrdinalIgnoreCase) ?? false).First().EQType];
                }
                if (equipType != weapon.EquipmentType)
                {
                    nw = nw == null ? state.PatchMod.Weapons.GetOrAddAsOverride(weapon)! : nw!;
                    nw.EquipmentType.SetTo(equipType);
                    Console.WriteLine($"\t\tChanged Equipment Type");
                }
                if (weapon.Data != null)
                {
                    WeaponAnimationType Animation = DB.DB[fKeyword].Animation;
                    if (DB.DB[fKeyword].ModOverrides.Any(x => x.Mod.Equals(weapon.FormKey.ModKey)))
                    {
                        ModOverride ovride = DB.DB[fKeyword].ModOverrides.Where(x => x.Mod.Equals(weapon.FormKey.ModKey)).First();
                        Animation = ovride.Animation;
                    }
                    if (Animation != weapon.Data.AnimationType)
                    {
                        nw = nw == null ? state.PatchMod.Weapons.GetOrAddAsOverride(weapon)! : nw!;
                        nw.Data!.AnimationType = Animation;
                        Console.WriteLine($"\t\tChanged Animation Type to {Animation}");
                    }
                }
                if (nw != null)
                {
                    foreach (var kyd in matchingKeywords)
                    {
                        var scripts = DB.DB[kyd].Script.Where(x => state.LoadOrder.ModExists(x.Requires, true));
                        foreach (var scr in scripts)
                        {
                            nw.VirtualMachineAdapter = nw.VirtualMachineAdapter == null ? new() : nw.VirtualMachineAdapter;
                            if (nw.VirtualMachineAdapter.Scripts.Any(x => x.Name == scr.ScriptName)) continue;
                            Console.WriteLine($"\t\tAttaching Script {scr.ScriptName}");
                            var script = new ScriptEntry()
                            {
                                Name = scr.ScriptName,
                            };
                            foreach (var prop in scr.Objects)
                            {
                                script.Properties.Add(new ScriptObjectProperty()
                                {
                                    Flags = ScriptProperty.Flag.Edited,
                                    Name = prop.Key,
                                    Object = prop.Value.ToLink<ISkyrimMajorRecordGetter>(),
                                });
                            }
                            nw.VirtualMachineAdapter.Scripts.Add(script);
                        }
                    }
                }
            }
        }
    }
}